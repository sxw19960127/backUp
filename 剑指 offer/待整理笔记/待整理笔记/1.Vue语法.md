---
title: Vue语法
date: 2019-08-01 07:34:52
tags: Vue全家桶
categories: Web前端开发
---

```
1.概述
前端开发效率的发展历程:
原生js -> jQuery类库 -> 前端模板引擎 -> 前端框架
	1)在各个浏览器中使用原生js,需要处理兼容性等问题 -> 出现jQuery;
	2)jQ解决了上述问题,但频繁地操作了DOM元素 -> 出现模板引擎;
	3)调用模板引擎提供的方法直接生成DOM元素,解决了上述问题,却又影响性能;
		例如: 给n个对象按id从小到大进行排序,模板引擎会傻瓜式地对所有数据进行处理,而不会辨别哪些数据是已经排序好不用变动位置的。所进行的每一次浏览器的重排重绘,都极大的影响了性能;	
--------------------------------------------------------------------
Vue特性:
	1)一套用于构建用户界面的渐进式框架,被设计为可以自底向上逐层应用;
	2)声明式渲染: Vue核心允许采用简洁的模板语法来声明式地将数据渲染进DOM的系统;
	3)提供双向数据绑定: 我们只需要关心业务逻辑,不用关心DOM是如何渲染的了;
	4)核心库只关注视图层,便于与第三方库或既有项目整合,易于上手;
	5)能减少不必要的DOM操作,提高渲染效率;
---------------------------------------------
前端: 负责MVC中的V层,和界面打交道来制作页面效果;
Node(后端)的MVC与前端的MVVM之间的区别:
	MVC是后端分层开发概念;
	MVVM是前端视图层概念,主要关注视图层分离为三部分: (Model/View/ViewModel);
---------------------------------------------------------------------
为什么要使用前端框架？
答: "保持UI和状态同步";
原生js创建UI的可读性很差,一些创建在html里,一些在js里,状态改变需要手动更新视图层,代码可读性差,代码脆弱;
前端模板引擎可以解决这个问题,但模板引擎又存在性能问题;
使用前端框架后,视图的添加及删除都由框架去完成,我们只需管理好数据和状态就行了;
```

```
2.安装
兼容性:
	1)Vue不支持IE8及以下版本;
	2)支持所有兼容ECMAScript5的浏览器;
辅助工具:
	Vue Devtools允许开发者在更友好的界面中审查和调试Vue;
    谷歌访问助手,下载地址: http://www.ggfwzs.com/
```

```
3.指令(会在渲染的DOM上应用特殊的响应式行为)
	1){{}} 双段号插值表达式
	2)v-cloak 解决页面加载时闪烁问题
	3)v-text 渲染文本
	4)v-html 渲染代码结构
	5)v-bind 属性绑定机制 缩写: 可写合法简单的js表达式(如: 三目运算符...);
	6)v-on 事件绑定机制 缩写@
------------------------------------------------------------------
小结:
    a.哪些指令存在闪烁问题: {{}} , v-html
    b.哪些指令会覆盖文本内容: v-text , v-html
        <p v-text="msg">此处填写内容无效</p>
        <p v-html="html">此处填写内容无效</p>
        <button :title="myTitle + '123'" @click="show"></button>
```

```
4.事件修饰符
.stop 阻止冒泡(阻止所有往外的冒泡)
.self 只当事件在该元素本身触发时触发回调(不让子元素的事件触发自己绑定的事件,但是不会阻止冒泡继续)
.prevent 阻止默认行为(a链接跳转等)
.capture 添加事件侦听器时使用事件捕获模式
.once 只触发一次
```

```
5.v-model双向数据绑定
```

```
6.属性绑定设置样式
	1)设置class类样式; v-bind:class  
	2)设置style行内样式; v-bind:style
```

```
7.v-for指令的四种用法
a)迭代数组
	<ul>
<li v-for="(item, i)in list">索引:{{i}} --- 姓名:{{item.name}} --- 年龄:{{item.age}}</li>
	</ul>
b)迭代对象属性
	<div v-for="(val,key,i)in userInfo">{{val}} --- {{key}} --- {{i}}</div>
c)迭代数字
	<p v-for="i in 10">第{{i}}个p标签</p>
d)迭代字符串
	 <p v-for="num in 'shuxiaowei'">{{ num }}</p>
注意: 在组件中使用v-for遍历,key值是必须的,提供唯一的key值以便跟踪每个节点的身份,重用和重新排序现有元素;
```

```
8.v-if和v-show区别
v-if: 重新删除或创建元素,有较高的切换性能消耗;
	如果元素永远也不会被显示出来被用户看到,推荐使用v-if;
v-show: 切换了元素的 display:none; 样式,有较高的初始渲染消耗;
	如果元素涉及频繁的切换,推荐使用v-show;
```

```
9.总结
a.MVVM是前端概念,把页面分为M V VM(VM是核心,是调度者,为我们提供双向数据绑定);
b.基本指令:
	插值表达式 {{}}
	v-cloak  
	v-text  
	v-html  
	v-bind 
	v-on
	v-model  
	v-for  
	v-if  
	v-show
c.事件修饰符:  
	.stop
	.prevent   
	.capture 
	.self  
	.once 
d.VM实例如果要访问data上的数据,methods中的方法,必须带this;
e.v-for循环要带key值(只接受string/number类型);
f.v-model只应用于表单元素;
g.在Vue中绑定样式只有两种方式: 
	v-bind:class  
	v-bind:style
h.Vue双向绑定实现原理 http://www.cnblogs.com/kidney/p/6052935.html
```

```
10.过滤器: 用作一些常见的文本格式化;
过滤器可用在两个地方: {{}}和v-bind表达式;
过滤器调用格式 {{ name | nameope }} 在输出name值之前,先调用nameope进行数值处理,并把最终结果进行渲染;
```

```
11.padStart 和 padEnd 字符串补全长度的功能,可在头部或尾部进行补全;
padStart()头部补全,padEnd()尾部补全;
padStart()和padEnd()共接受两个参数:
	第一个参数用来指定字符串的最小长度;
	第二个参数用来补全的字符串;
----------------------------------
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'
'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
---------------------------------------------------
如果原字符串的长度等于或大于指定的最小长度,则返回原字符串;
'xxx'.padStart(2, 'ab') // 'xxx'
'xxx'.padEnd(2, 'ab') // 'xxx'
------------------------------------------------------------------------------
如果用来补全的字符串与原字符串两者长度之和超过了指定的最小长度,则会截去超出位数的补全字符串。
'abc'.padStart(10, '0123456789') //'0123456abc'
--------------------------------------
如果省略第二个参数,则默认使用空格补全长度;
'x'.padStart(4) // ' x'
'x'.padEnd(4) // 'x '
--------------------------------
用途: 提示字符串格式
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
```

```
12.按键修饰符:
.enter
.tab
.delete
.esc
.space
.up
.down
.left
.right
不确定的键可以参照js键盘事件对应的键码去找keyCode:
js键盘事件对应的键码: http://www.cnblogs.com/wuhua1/p/6686237.html
```

```
13.自定义全局指令让文本框获取焦点
Vue.directive('',{}); //定义全局指令
参数1: 指令名称; 
	定义指令名称时前面不需要加 v- 前缀,调用时需要在指令名称前加上 v- 前缀;
参数2: 是一个对象;
	对象身上有一些指令相关的函数,这些函数可在特定的阶段,执行相关的操作;
注意: 在插入阶段书写代码才能生效;
-------------------------------------------------------------------------
Vue.directive('focus', { 
    // 每个函数中第一个参数永远是el,表示被绑定了指令的那个元素,el是一个原生js对象;
    // 当元素插入DOM才能获得焦点;
    bind: function() {
        //el.focus() 在元素刚绑定指令还没有插入到DOM中去时调用focus方法没有作用;
    },
    inserted: function(el) { //元素插入DOM中会执行inserted函数,且只触发一次;
        el.focus()
    },
    updated: function() { //当VNode更新时,会执行updated函数,可能会触发多次

    }
})
```

```
14.使用钩子函数的第二个binding参数拿到传递的值
自定义字体颜色的指令;
<input type="text" v-model="keywords" v-color="'blue'">
Vue.directive('color', {
    // 只要通过指令绑定给了元素,不管这个元素有没有被插入到页面中,肯定会有一个内联样式;
    // 将来元素肯定会显示在页面中,浏览器的渲染引擎必然会解析样式应用给这个元素,所以在bind中设置;
    bind: function(el, binding) { //只要和样式相关的都设置在bind里;
        // console.log(binding.name)
        // console.log(binding.value)
        el.style.color = binding.value
    	}
    }
})
```

```
15.定义私有指令
<h3 v-fontweight="900"></h3>
var vm = new Vue({
	el: '#app',
	directives: {
		'fontweight': function(el, binding) { 
			el.style.fontWeight = binding.value; 
		}
	}
})
```

```
16.生命周期函数-组件运行和销毁期间的4个钩子函数
生命周期: 从Vue实例创建、运行、到销毁期间,总是伴随着各种各样的事件,这些事件统称生命周期;
a)创建期间的生命周期函数:
	beforeCreate: 实例刚在内存中被创建出来,还没有初始化好data和methods属性;
	created: 实例已经在内存中创建OK,此时data和methods已经创建OK,还没有开始编译模板;
	beforeMount: 此时已经完成了模板的编译,但还没有挂载到页面中;
	mounted: 此时已经将编译好的模板挂载到了页面指定容器中显示;
b)运行期间的生命周期函数:
	beforeUpdate: 状态更新之前执行此函数,此时data中的状态值是最新的,但是界面上显示的数据还是旧的,因为此时还没有开始重新渲染DOM节点;
	updated: 实例更新完毕之后调用此函数,此时data中的状态值和界面上显示的数据都已经完成了更新,界面已经被重新渲染好了;
c)销毁期间的生命周期函数:
	beforeDestroy: 实例销毁之前调用,在这一步,实例仍然完全可用;
	destroyed: Vue实例销毁后调用,调用后Vue实例指示的所有东西都会解绑定,所有的事件监听器会被移除,所有的子实例也会被销毁;
```

```
17.watch、computed、methods
1.watch 对象,键是需要观察的表达式,值是对应的回调函数,主要用来监听某些特定数据的变化,从而进行某些具体的业务逻辑操作,可以看作是 computed 和 methods 的结合体;
2.computed 结果会被缓存,除非依赖的响应式属性变化才会重新计算,主要当作属性来使用;
3.methods 表示一个具体的操作,主要书写业务逻辑;
-----------------------------------------------------
计算属性: watch/computed
watch不需要返回值,可以直接写逻辑操作;
计算属性里只能写同步的操作,当数据发生变化自动监听响应式反应,而watch可以写异步操作;
----------------------------------------------------------------------------------
三种监听属性的方式:
a)原生用函数执行的方式: 页面上只要发生数据变化函数都会执行,用以确保此时渲染的数据是最新的,非常耗费性能;
b)computed: 会分析数据的变化是否与自己定义的函数所涉及的数据相关,进行更新;
c)watch: 和computed差不多,但watch里可以有异步操作的存在,且不需要返回值;
```

```
19.nrm
作用: 提供最常用的npm包镜像地址,能够让我们快速的切换安装包时候的服务器地址;
镜像: 一开始,包只存在于国外的npm服务器上,但由于网络原因,经常访问不到,这时我们在国内创建一个和官网完全一样的npm服务器,只不过数据都是从人家那里拿过来的,除此之外,使用方式完全一样;
-----------------------------------------------------------------
npm下载包的地址: registry.npmjs.org (此网址属于国外的,下包速度慢)
为了提高装包的速度,可以使用工具nrm
a.npm i nrm -g '全局安装nrm包'
b.nrm ls '查看当前所有可用的镜像源地址以及当前所使用的镜像源地址'
  npm ---- https://registry.npmjs.org/
  cnpm --- http://r.cnpmjs.org/
* taobao - https://registry.npm.taobao.org/
  nj ----- https://registry.nodejitsu.com/
  npmMirror  https://skimdb.npmjs.com/registry/
  edunpm - http://registry.enpmjs.org/
c.nrm use npm '切换不同的镜像源地址'
注意: nrm提供了几个常用的下包地址,但是我们每次装包时所使用的装包工具依旧是npm;
```

```
考点1: 
Vue实例上三个重要属性:
	$el: (该Vue实例所控制的代码段)
	_data: (我们传进去的data)
	$refs: (获得所控制代码块的dom节点)
------------------------------------------------------
考点2: 
Vue底层原理 - 数据绑定的实现
Object.definedProperty(vm, "title", { get(){},set(){} )
由于Vue是用ES5写的,而IE8及以下是不支持ES5的,也就不支持Vue;
Vue底层为我们做了两件事情: 
1.将我们new出来的对象上的所有属性和方法中的this指向全部都指向当前的Vue实例,即保证了this指向的一致;
2.将属性和方法全部挂载到Vue对象上,这是我们就可以通过this去获取到;
数据通过set函数去监听他;
---------------------------------------------------------------
考点3: 虚拟dom
虚拟dom先生成一个对象,利用js引擎运行速度很快以及diff算法先进行过滤一遍(将新数据和旧数据进行对比,比较哪些是发生变化了的),我们仅仅对有差异的进行重新渲染;
```

```
真实开发需要:
	服务器
	Babel
	postcss(后处理器)
	less sass(预处理器)
	esLint(代码规范)
```

```
Vue脚手架搭建项目:
	1.npm install -g @vue/cli
	2.vue --version 确认是否已经安装cli以及查看版本号
	3.卸载旧版本命令 npm uninstall vue-cli -g
	
	4.cd Desktop/
	5.vue create vue-test
	6.选工具,默认是babel&esLint,可以上下键进行选择,选择下面的自定义,按空格键以确定,回车;
	7.选择代码规范,选择只是错误而已,with error prevention only 回车;
	8.选择Lint特性,按照默认的来,回车;
	9.是否将每个文件都生成一个配置文件,直接生成一个文件package.json,选择每个文件都独立成一个配置文件;
	10.你会将之前所有的操作当作一个习惯来保存吗;
	11.安装;
	12.安装完成 cd vue-test/
	13.npm run serve 启动项目
--------------------------------------------------------
开启图形化界面:
	a.*用以快速修改项目配置,里面还有build打包等操作 
	b.cd Desktop/     
	c.vue ui	
	d.导入vue-test项目
```

